{% set s_color = color | default(value="accent") %}
{% set s_size = font_size | default(value="1.5rem") %}
{% set s_weight = font_weight | default(value="bold") %}
{% set s_stroke = stroke_width | default(value="4") %}
{% set s_head = head_size | default(value="10") %}
{% set s_spacing = spacing | default(value="10") %}

{# Resolve Color Variables #}
{% if s_color == "accent" %}
    {% set final_color = "var(--accent-color)" %}
{% elif s_color == "text" %}
    {% set final_color = "var(--fg-color)" %} 
{% else %}
    {% set final_color = s_color %}
{% endif %}

<span class="arrow-note" 
      style="color: {{ final_color }}; font-size: {{ s_size }}; font-weight: {{ s_weight }};"
      data-target-id="{{ target }}" 
      data-start-dir="{{ start_dir | default(value='bottom') }}" 
      data-end-dir="{{ end_dir | default(value='bottom') }}"
      data-color="{{ final_color }}"
      data-stroke-width="{{ s_stroke }}"
      data-head-size="{{ s_head }}"
      data-spacing="{{ s_spacing }}"
      {% if amplitude %}data-amplitude="{{ amplitude }}"{% endif %}
      {% if amplitude_desktop %}data-amplitude-desktop="{{ amplitude_desktop }}"{% endif %}
      {% if easing %}data-easing="{{ easing }}"{% endif %}
      {% if ease_out %}data-ease-out="{{ ease_out }}"{% endif %}
      {% if ease_in %}data-ease-in="{{ ease_in }}"{% endif %}
      {% if lock_bottom %}data-lock-bottom="{{ lock_bottom }}"{% endif %}
      {% if bottom_offset %}data-bottom-offset="{{ bottom_offset }}"{% endif %}>
    {{ text | safe }}
</span>

<script>
(function() {
    const arrows = [];
    let resizeTimeout;

    function initArrowNotes() {
        const notes = document.querySelectorAll('.arrow-note');
        
        notes.forEach(note => {
            if (note.dataset.processed) return;
            
            const targetId = note.dataset.targetId;
            const target = document.getElementById(targetId);
            
            if (!target) {
                // Retry once for late-rendering frameworks
                setTimeout(() => {
                   const retryTarget = document.getElementById(targetId); 
                   if(retryTarget) registerArrow(note, retryTarget);
                }, 500);
                return;
            }
            
            registerArrow(note, target);
        });
    }

    function registerArrow(note, target) {
        // Create SVG layer if needed
        let svg = document.getElementById('arrow-layer');
        if (!svg) {
            svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.id = "arrow-layer";
            svg.style.position = "absolute";
            svg.style.top = "0";
            svg.style.left = "0";
            svg.style.width = "100%";
            svg.style.height = "100%";
            svg.style.pointerEvents = "none";
            svg.style.zIndex = "900";
            svg.style.overflow = "visible";
            
            // Add Filters for Line Boil
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
            const createBoilFilters = (prefix, scale) => {
                [1, 2, 3].forEach(i => {
                    const f = document.createElementNS("http://www.w3.org/2000/svg", "filter");
                    f.id = `${prefix}${i}`;
                    f.setAttribute("x", "-20%");
                    f.setAttribute("y", "-20%");
                    f.setAttribute("width", "140%");
                    f.setAttribute("height", "140%");
                    
                    const turb = document.createElementNS("http://www.w3.org/2000/svg", "feTurbulence");
                    turb.setAttribute("type", "fractalNoise");
                    turb.setAttribute("baseFrequency", "0.03");
                    turb.setAttribute("numOctaves", "1");
                    turb.setAttribute("seed", i * 10);
                    turb.setAttribute("result", "noise");
                    
                    const disp = document.createElementNS("http://www.w3.org/2000/svg", "feDisplacementMap");
                    disp.setAttribute("in", "SourceGraphic");
                    disp.setAttribute("in2", "noise");
                    disp.setAttribute("scale", scale);
                    disp.setAttribute("xChannelSelector", "R");
                    disp.setAttribute("yChannelSelector", "G");
                    
                    f.appendChild(turb);
                    f.appendChild(disp);
                    defs.appendChild(f);
                });
            };

            createBoilFilters('boil', 3);
            createBoilFilters('boilText', 1.5);

            svg.appendChild(defs);
            document.body.appendChild(svg);
        }

        // Configuration
        const color = note.dataset.color;
        const strokeWidth = parseFloat(note.dataset.strokeWidth);
        const headSize = parseFloat(note.dataset.headSize);
        const spacing = parseFloat(note.dataset.spacing);
        const customAmp = note.dataset.amplitude ? parseFloat(note.dataset.amplitude) : null;
        const customAmpDesktop = note.dataset.amplitudeDesktop ? parseFloat(note.dataset.amplitudeDesktop) : null;
        const baseEasing = note.dataset.easing ? parseFloat(note.dataset.easing) : 0;
        const easeOut = note.dataset.easeOut ? parseFloat(note.dataset.easeOut) : baseEasing;
        const easeIn = note.dataset.easeIn ? parseFloat(note.dataset.easeIn) : baseEasing;
        const lockBottom = note.dataset.lockBottom === "true";
        const bottomOffset = note.dataset.bottomOffset ? parseFloat(note.dataset.bottomOffset) : 10;
        
        const startDir = note.dataset.startDir;
        const endDir = note.dataset.endDir;

        // Create Group
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.classList.add("arrow-path-boil");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", color);
        path.setAttribute("stroke-width", strokeWidth);
        path.setAttribute("stroke-linecap", "round");
        
        const head = document.createElementNS("http://www.w3.org/2000/svg", "path");
        head.classList.add("arrow-path-boil");
        head.setAttribute("fill", "none");
        head.setAttribute("stroke", color);
        head.setAttribute("stroke-width", strokeWidth);
        head.setAttribute("stroke-linecap", "round");
        head.setAttribute("stroke-linejoin", "round");

        group.appendChild(path);
        group.appendChild(head);
        
        group.style.opacity = "0";
        group.style.transition = "opacity 0.2s ease"; 
        svg.appendChild(group);

        const arrowData = {
            note,
            target,
            group,
            path,
            head,
            config: {
                startDir, endDir, headSize, customAmp, customAmpDesktop, easeOut, easeIn, spacing, lockBottom, bottomOffset
            }
        };
        
        arrows.push(arrowData);
        note.dataset.processed = "true";
        
        // Initial render
        updateArrow(arrowData);
    }

    function updateArrow(arrow) {
        const { note, target, group, path, head, config } = arrow;

        // Simple visibility check
        if (note.offsetParent === null) {
            if (group.style.opacity !== "0") group.style.opacity = "0";
            return;
        }

        const r1 = note.getBoundingClientRect();
        const r2 = target.getBoundingClientRect();
        const scrollX = window.scrollX;
        const scrollY = window.scrollY;

        // Calculate points
        let x1, y1, x2, y2;

        // Start Point
        const spacing = config.spacing;
        switch(config.startDir) {
            case 'top': x1 = r1.left + r1.width/2; y1 = r1.top - spacing; break;
            case 'bottom': x1 = r1.left + r1.width/2; y1 = r1.bottom + spacing; break;
            case 'left': x1 = r1.left - spacing; y1 = r1.top + r1.height/2; break;
            case 'right': x1 = r1.right + spacing; y1 = r1.top + r1.height/2; break;
        }

        // End Point
        switch(config.endDir) {
            case 'top': x2 = r2.left + r2.width/2; y2 = r2.top - spacing; break;
            case 'bottom': x2 = r2.left + r2.width/2; y2 = r2.bottom + spacing; break;
            case 'left': x2 = r2.left - spacing; y2 = r2.top + r2.height/2; break;
            case 'right': x2 = r2.right + spacing; y2 = r2.top + r2.height/2; break;
        }

        // Lock Bottom Logic
        if (config.lockBottom) {
             y2 = window.innerHeight - config.bottomOffset;
        }

        // Add scroll
        x1 += scrollX; y1 += scrollY;
        x2 += scrollX; y2 += scrollY;

        // Bezier
        let curve;
        const isDesktop = window.innerWidth > 768;
        const effectiveAmp = (isDesktop && config.customAmpDesktop !== null) ? config.customAmpDesktop : config.customAmp;

        if (effectiveAmp !== null) {
            curve = effectiveAmp;
        } else {
            const dist = Math.hypot(x2-x1, y2-y1);
            curve = Math.min(Math.max(dist * 0.5, 50), 200);
        }

        let cp1x = x1, cp1y = y1, cp2x = x2, cp2y = y2;

        switch(config.startDir) {
            case 'top': cp1y -= curve; cp1x += config.easeOut; break;
            case 'bottom': cp1y += curve; cp1x += config.easeOut; break;
            case 'left': cp1x -= curve; cp1y += config.easeOut; break;
            case 'right': cp1x += curve; cp1y += config.easeOut; break;
        }

        switch(config.endDir) {
            case 'top': cp2y -= curve; cp2x += config.easeIn; break;
            case 'bottom': cp2y += curve; cp2x += config.easeIn; break;
            case 'left': cp2x -= curve; cp2y += config.easeIn; break;
            case 'right': cp2x += curve; cp2y += config.easeIn; break;
        }

        const d = `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
        path.setAttribute("d", d);

        // Arrow Head
        const angle = Math.atan2(y2 - cp2y, x2 - cp2x);
        const headLen = config.headSize;
        const headAngle = Math.PI / 6;

        const p1x = x2 - headLen * Math.cos(angle - headAngle);
        const p1y = y2 - headLen * Math.sin(angle - headAngle);
        const p2x = x2 - headLen * Math.cos(angle + headAngle);
        const p2y = y2 - headLen * Math.sin(angle + headAngle);

        const headD = `M ${p1x} ${p1y} L ${x2} ${y2} L ${p2x} ${p2y}`;
        head.setAttribute("d", headD);

        if (group.style.opacity !== "1") group.style.opacity = "1";
    }

    function updateAll() {
        arrows.forEach(updateArrow);
    }

    function onResize() {
        // Debounce resize to avoid thrashing during window drag
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            requestAnimationFrame(updateAll);
        }, 100);
    }

    // Initialize
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            initArrowNotes();
            updateAll();
        });
    } else {
        initArrowNotes();
        updateAll();
    }
    
    window.addEventListener('load', updateAll);
    window.addEventListener('resize', onResize);

})();
</script>
