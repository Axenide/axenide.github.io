{% set s_color = color | default(value="accent") %}
{% set s_size = font_size | default(value="1.5rem") %}
{% set s_weight = font_weight | default(value="bold") %}
{% set s_stroke = stroke_width | default(value="4") %}
{% set s_head = head_size | default(value="10") %}
{% set s_spacing = spacing | default(value="10") %}

{# Resolve Color Variables #}
{% if s_color == "accent" %}
    {% set final_color = "var(--accent-color)" %}
{% elif s_color == "text" %}
    {% set final_color = "var(--fg-color)" %} 
{% else %}
    {% set final_color = s_color %}
{% endif %}

<span class="arrow-note" 
      style="color: {{ final_color }}; font-size: {{ s_size }}; font-weight: {{ s_weight }};"
      data-target-id="{{ target }}" 
      data-start-dir="{{ start_dir | default(value='bottom') }}" 
      data-end-dir="{{ end_dir | default(value='bottom') }}"
      data-color="{{ final_color }}"
      data-stroke-width="{{ s_stroke }}"
      data-head-size="{{ s_head }}"
      data-spacing="{{ s_spacing }}"
      {% if amplitude %}data-amplitude="{{ amplitude }}"{% endif %}
      {% if amplitude_desktop %}data-amplitude-desktop="{{ amplitude_desktop }}"{% endif %}
      {% if easing %}data-easing="{{ easing }}"{% endif %}
      {% if ease_out %}data-ease-out="{{ ease_out }}"{% endif %}
      {% if ease_in %}data-ease-in="{{ ease_in }}"{% endif %}
      {% if lock_bottom %}data-lock-bottom="{{ lock_bottom }}"{% endif %}
      {% if bottom_offset %}data-bottom-offset="{{ bottom_offset }}"{% endif %}>
    {{ text | safe }}
</span>

<script>
(function() {
    // State to track visible arrows (Performance Optimization)
    const visibleArrows = new Set();
    
    // IntersectionObserver to only update arrows when the note is in viewport
    // rootMargin: "50%" ensures arrows update slightly before entering screen
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const arrowData = entry.target._arrowData;
            if (!arrowData) return;

            if (entry.isIntersecting) {
                visibleArrows.add(arrowData);
                // Ensure visible immediately
                if (arrowData.group.style.opacity !== "1") arrowData.group.style.opacity = "1";
            } else {
                visibleArrows.delete(arrowData);
                // Hide when off-screen to prevent artifacts/confusion
                // But only if we are sure (optional, keeping it visible doesn't hurt if loop stops)
                // Leaving opacity management to the visibility check in loop for smoother transitions
            }
        });
    }, { rootMargin: "50% 0px 50% 0px" });

    function initArrowNotes() {
        const notes = document.querySelectorAll('.arrow-note');
        
        notes.forEach(note => {
            if (note.dataset.processed) return;
            
            const targetId = note.dataset.targetId;
            const target = document.getElementById(targetId);
            
            if (!target) {
                setTimeout(() => {
                   const retryTarget = document.getElementById(targetId); 
                   if(retryTarget) registerArrow(note, retryTarget);
                }, 500);
                return;
            }
            
            registerArrow(note, target);
        });
    }

    function registerArrow(note, target) {
        // Create SVG layer if needed
        let svg = document.getElementById('arrow-layer');
        if (!svg) {
            svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.id = "arrow-layer";
            svg.style.position = "absolute";
            svg.style.top = "0";
            svg.style.left = "0";
            svg.style.width = "100%";
            svg.style.height = "100%";
            svg.style.pointerEvents = "none";
            svg.style.zIndex = "900";
            svg.style.overflow = "visible";
            
            // Add Filters for Line Boil
            const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
            
            const createBoilFilters = (prefix, scale) => {
                [1, 2, 3].forEach(i => {
                    const f = document.createElementNS("http://www.w3.org/2000/svg", "filter");
                    f.id = `${prefix}${i}`;
                    f.setAttribute("x", "-20%");
                    f.setAttribute("y", "-20%");
                    f.setAttribute("width", "140%");
                    f.setAttribute("height", "140%");
                    
                    const turb = document.createElementNS("http://www.w3.org/2000/svg", "feTurbulence");
                    turb.setAttribute("type", "fractalNoise");
                    turb.setAttribute("baseFrequency", "0.03");
                    turb.setAttribute("numOctaves", "1");
                    turb.setAttribute("seed", i * 10);
                    turb.setAttribute("result", "noise");
                    
                    const disp = document.createElementNS("http://www.w3.org/2000/svg", "feDisplacementMap");
                    disp.setAttribute("in", "SourceGraphic");
                    disp.setAttribute("in2", "noise");
                    disp.setAttribute("scale", scale);
                    disp.setAttribute("xChannelSelector", "R");
                    disp.setAttribute("yChannelSelector", "G");
                    
                    f.appendChild(turb);
                    f.appendChild(disp);
                    defs.appendChild(f);
                });
            };

            createBoilFilters('boil', 3);
            createBoilFilters('boilText', 1.5);

            svg.appendChild(defs);
            document.body.appendChild(svg);
        }

        // Configuration
        const color = note.dataset.color;
        const strokeWidth = parseFloat(note.dataset.strokeWidth);
        const headSize = parseFloat(note.dataset.headSize);
        const spacing = parseFloat(note.dataset.spacing);
        const customAmp = note.dataset.amplitude ? parseFloat(note.dataset.amplitude) : null;
        const customAmpDesktop = note.dataset.amplitudeDesktop ? parseFloat(note.dataset.amplitudeDesktop) : null;
        const baseEasing = note.dataset.easing ? parseFloat(note.dataset.easing) : 0;
        const easeOut = note.dataset.easeOut ? parseFloat(note.dataset.easeOut) : baseEasing;
        const easeIn = note.dataset.easeIn ? parseFloat(note.dataset.easeIn) : baseEasing;
        const lockBottom = note.dataset.lockBottom === "true";
        const bottomOffset = note.dataset.bottomOffset ? parseFloat(note.dataset.bottomOffset) : 10;
        
        const startDir = note.dataset.startDir;
        const endDir = note.dataset.endDir;

        // Create Group
        const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
        
        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path.classList.add("arrow-path-boil");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", color);
        path.setAttribute("stroke-width", strokeWidth);
        path.setAttribute("stroke-linecap", "round");
        
        const head = document.createElementNS("http://www.w3.org/2000/svg", "path");
        head.classList.add("arrow-path-boil");
        head.setAttribute("fill", "none");
        head.setAttribute("stroke", color);
        head.setAttribute("stroke-width", strokeWidth);
        head.setAttribute("stroke-linecap", "round");
        head.setAttribute("stroke-linejoin", "round");

        group.appendChild(path);
        group.appendChild(head);
        
        group.style.opacity = "0";
        group.style.transition = "opacity 0.2s ease"; 
        svg.appendChild(group);

        const arrowData = {
            note,
            target,
            group,
            path,
            head,
            config: {
                startDir, endDir, headSize, customAmp, customAmpDesktop, easeOut, easeIn, spacing, lockBottom, bottomOffset
            },
            prevCoords: null
        };
        
        // Link and observe
        note._arrowData = arrowData;
        note.dataset.processed = "true";
        observer.observe(note);
    }

    // Optimized Animation Loop
    function loop() {
        if (visibleArrows.size > 0) {
            
            // PHASE 1: READ (Batch all DOM reads)
            // -----------------------------------
            const scrollX = window.scrollX;
            const scrollY = window.scrollY;
            const updates = [];

            for (const arrow of visibleArrows) {
                const { note, target, prevCoords } = arrow;

                // Optimization: offsetParent checks if element or ancestors are display:none
                if (note.offsetParent === null) {
                    if (arrow.group.style.opacity !== "0") arrow.group.style.opacity = "0";
                    continue; 
                }

                // If we need strict visibility check (e.g. visibility: hidden)
                // We do it here, but it triggers style recalc. 
                // Using offsetParent covers most cases (display: none).
                // We can assume if it's in viewport (via Observer) and not display:none, we render.

                const r1 = note.getBoundingClientRect();
                const r2 = target.getBoundingClientRect();

                // Check for changes efficiently
                const currentCoords = JSON.stringify({
                    r1: {x: Math.round(r1.x), y: Math.round(r1.y), w: Math.round(r1.width), h: Math.round(r1.height)},
                    r2: {x: Math.round(r2.x), y: Math.round(r2.y), w: Math.round(r2.width), h: Math.round(r2.height)},
                    scrollX, scrollY
                });

                if (prevCoords === currentCoords) continue;
                
                // Queue for update
                arrow.prevCoords = currentCoords;
                updates.push({ arrow, r1, r2, scrollX, scrollY });
            }

            // PHASE 2: WRITE (Batch all DOM writes)
            // ------------------------------------
            for (const update of updates) {
                const { arrow, r1, r2, scrollX, scrollY } = update;
                const { config, group, path, head } = arrow;

                // Calculate points
                let x1, y1, x2, y2;

                // Start Point
                const spacing = config.spacing;
                switch(config.startDir) {
                    case 'top': x1 = r1.left + r1.width/2; y1 = r1.top - spacing; break;
                    case 'bottom': x1 = r1.left + r1.width/2; y1 = r1.bottom + spacing; break;
                    case 'left': x1 = r1.left - spacing; y1 = r1.top + r1.height/2; break;
                    case 'right': x1 = r1.right + spacing; y1 = r1.top + r1.height/2; break;
                }

                // End Point
                switch(config.endDir) {
                    case 'top': x2 = r2.left + r2.width/2; y2 = r2.top - spacing; break;
                    case 'bottom': x2 = r2.left + r2.width/2; y2 = r2.bottom + spacing; break;
                    case 'left': x2 = r2.left - spacing; y2 = r2.top + r2.height/2; break;
                    case 'right': x2 = r2.right + spacing; y2 = r2.top + r2.height/2; break;
                }

                // Lock Bottom Logic
                if (config.lockBottom) {
                     y2 = window.innerHeight - config.bottomOffset;
                }

                // Add scroll for absolute coordinates
                x1 += scrollX; y1 += scrollY;
                x2 += scrollX; y2 += scrollY;

                // Bezier Logic
                let curve;
                const isDesktop = window.innerWidth > 768; // Read from window is cheap enough here
                const effectiveAmp = (isDesktop && config.customAmpDesktop !== null) ? config.customAmpDesktop : config.customAmp;

                if (effectiveAmp !== null) {
                    curve = effectiveAmp;
                } else {
                    const dist = Math.hypot(x2-x1, y2-y1);
                    curve = Math.min(Math.max(dist * 0.5, 50), 200);
                }

                let cp1x = x1, cp1y = y1, cp2x = x2, cp2y = y2;

                switch(config.startDir) {
                    case 'top': cp1y -= curve; cp1x += config.easeOut; break;
                    case 'bottom': cp1y += curve; cp1x += config.easeOut; break;
                    case 'left': cp1x -= curve; cp1y += config.easeOut; break;
                    case 'right': cp1x += curve; cp1y += config.easeOut; break;
                }

                switch(config.endDir) {
                    case 'top': cp2y -= curve; cp2x += config.easeIn; break;
                    case 'bottom': cp2y += curve; cp2x += config.easeIn; break;
                    case 'left': cp2x -= curve; cp2y += config.easeIn; break;
                    case 'right': cp2x += curve; cp2y += config.easeIn; break;
                }

                const d = `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
                
                // Arrow Head
                const angle = Math.atan2(y2 - cp2y, x2 - cp2x);
                const headLen = config.headSize;
                const headAngle = Math.PI / 6;

                const p1x = x2 - headLen * Math.cos(angle - headAngle);
                const p1y = y2 - headLen * Math.sin(angle - headAngle);
                const p2x = x2 - headLen * Math.cos(angle + headAngle);
                const p2y = y2 - headLen * Math.sin(angle + headAngle);

                const headD = `M ${p1x} ${p1y} L ${x2} ${y2} L ${p2x} ${p2y}`;

                // Apply DOM updates
                path.setAttribute("d", d);
                head.setAttribute("d", headD);

                if (group.style.opacity !== "1") group.style.opacity = "1";
            }
        }
        requestAnimationFrame(loop);
    }

    // Initialize
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            initArrowNotes();
            loop(); 
        });
    } else {
        initArrowNotes();
        loop();
    }
    
    window.addEventListener('load', initArrowNotes);
})();
</script>
