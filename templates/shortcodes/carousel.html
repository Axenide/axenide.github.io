<div class="carousel-container" data-interval="{{ interval | default(value=0) }}">
    <div class="carousel-track">
        {% for i in range(end=3) %}
            {% for image in images %}
                <div class="carousel-item" data-real-index="{{ loop.index0 }}" onclick="onItemClick(this)">
                    <img src="{{ image }}#transparent" class="no-hover" alt="Slide" loading="lazy" />
                </div>
            {% endfor %}
        {% endfor %}
    </div>
</div>

<div class="lightbox-overlay" onclick="closeLightbox(this)">
    <img class="lightbox-img" src="" alt="Full size view" />
</div>

<script>
    function onItemClick(item) {
        const container = item.closest('.carousel-container');
        if (container.handleItemClick) {
            container.handleItemClick(item);
        }
    }

    function closeLightbox(overlay) {
        overlay.classList.remove('visible');
        document.body.style.overflow = '';
        const container = overlay.previousElementSibling;
        if (container && container.resumeTimer) container.resumeTimer();
    }

    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.querySelectorAll('.lightbox-overlay.visible').forEach(closeLightbox);
        }
    });

    (function() {
        const script = document.currentScript;
        const lightbox = script.previousElementSibling;
        const container = lightbox.previousElementSibling;
        const track = container.querySelector('.carousel-track');
        const allItems = Array.from(track.querySelectorAll('.carousel-item'));
        
        const intervalTime = parseInt(container.dataset.interval);
        const setSize = allItems.length / 3;
        
        let currentIndex = setSize; 
        let isAnimating = false;
        let timerId = null;
        let scrollTimeout = null;

        container.handleItemClick = (clickedItem) => {
            if (clickedItem.classList.contains('active')) {
                const img = clickedItem.querySelector('img');
                openLightbox(img.src);
            } else {
                const index = allItems.indexOf(clickedItem);
                scrollToIndex(index, 'smooth');
            }
        };

        container.resumeTimer = startTimer;

        function openLightbox(src) {
            const img = lightbox.querySelector('img');
            img.src = src;
            lightbox.classList.add('visible');
            document.body.style.overflow = 'hidden';
            stopTimer();
        }

        function stopTimer() {
            if (timerId) {
                clearInterval(timerId);
                timerId = null;
            }
        }

        function startTimer() {
            if (lightbox.classList.contains('visible')) return;
            if (intervalTime > 0) {
                stopTimer();
                timerId = setInterval(nextSlide, intervalTime);
            }
        }

        function scrollToIndex(index, behavior = 'smooth') {
            currentIndex = index;
            const targetItem = allItems[index];
            
            const containerCenter = track.clientWidth / 2;
            const itemCenter = targetItem.offsetWidth / 2;
            const targetLeft = targetItem.offsetLeft - containerCenter + itemCenter;

            // MODO SIGILOSO (TELETRANSPORTE)
            if (behavior === 'auto') {
                // 1. Apagar transiciones
                track.classList.add('no-transition');
                
                // 2. Mover scroll
                track.scrollTo({ left: targetLeft, behavior: 'auto' });
                
                // 3. Forzar Layout (Reflow) para que el navegador "digiera" el cambio sin animar
                void track.offsetHeight; 
                
                // 4. Actualizar estado visual (Active/Inactive) INSTANTÁNEAMENTE
                updateVisualClasses(true); // true = force sync
                
                // 5. Reactivar transiciones (después de un frame para seguridad)
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        track.classList.remove('no-transition');
                    });
                });
            } else {
                // MODO NORMAL (ANIMADO)
                isAnimating = true;
                track.scrollTo({ left: targetLeft, behavior: behavior });
                updateVisualClasses();
            }
        }

        function nextSlide() {
            scrollToIndex(currentIndex + 1, 'smooth');
        }

        function updateVisualClasses(forceSync = false) {
            const centerPoint = track.scrollLeft + (track.clientWidth / 2);
            let closest = null;
            let minDistance = Infinity;

            allItems.forEach((item, i) => {
                const itemCenter = item.offsetLeft + (item.offsetWidth / 2);
                const distance = Math.abs(centerPoint - itemCenter);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closest = item;
                    if (!isAnimating || forceSync) currentIndex = i; 
                }
                item.classList.remove('active');
            });

            if (closest) closest.classList.add('active');
        }

        function checkTeleport() {
            isAnimating = false;

            if (currentIndex < setSize) {
                const realIndex = currentIndex + setSize;
                scrollToIndex(realIndex, 'auto');
            } 
            else if (currentIndex >= setSize * 2) {
                const realIndex = currentIndex - setSize;
                scrollToIndex(realIndex, 'auto');
            }
        }

        setTimeout(() => {
            scrollToIndex(currentIndex, 'auto'); 
            startTimer();
        }, 100);

        track.addEventListener('scroll', () => {
            if (!track.classList.contains('no-transition')) {
                requestAnimationFrame(() => updateVisualClasses());
            }

            if (scrollTimeout) clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(checkTeleport, 100);
        });

        // Refinado: Solo pausar si el mouse está sobre el track (imágenes)
        track.addEventListener('mouseenter', stopTimer);
        track.addEventListener('mouseleave', startTimer);
        
        window.addEventListener('resize', () => scrollToIndex(currentIndex, 'auto'));

    })();
</script>
